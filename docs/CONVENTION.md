# Hipster 프로젝트 컨벤션 가이드

본 문서는 Hipster 프로젝트의 원활한 협업을 위한 커밋 메시지 및 코딩 컨벤션을 정의합니다. 모든 팀원은 아래 규칙을 숙지하고 준수해야 합니다.

---

## 1. 커밋 컨벤션 (Commit Convention)

일관성 있는 커밋 히스토리 관리를 위해 Angular Commit Message Convention을 따릅니다.

### 1.1. 커밋 메시지 형식

모든 커밋 메시지는 아래와 같은 형식으로 작성하며, 제목과 본문을 포함할 수 있습니다.

```
type(scope): subject
<BLANK LINE>
body
<BLANK LINE>
footer
```

- **type**: 커밋의 종류를 나타냅니다. (아래 타입 목록 참고)
- **scope**: 변경된 코드의 범위를 나타냅니다. (선택 사항)
- **subject**: 커밋에 대한 간결한 요약입니다.
- **body**: 커밋의 상세 내용, '무엇을, 왜' 변경했는지 설명합니다. (선택 사항)
- **footer**: 이슈 트래커 ID 등을 명시합니다. (선택 사항)

**예시:**
```
feat(auth): Google OAuth2 로그인 기능 구현

- 사용자는 Google 계정을 통해 서비스에 가입하고 로그인할 수 있습니다.
- OAuth2 프로토콜을 준수하여 Access Token 및 Refresh Token을 발급합니다.

Closes #21
```

### 1.2. Type 종류

| 타입      | 설명                               |
| --------- | ---------------------------------- |
| **feat**  | 새로운 기능 추가                   |
| **fix**   | 버그 수정                          |
| **docs**  | 문서 추가 또는 수정                |
| **style** | 코드 포맷팅, 세미콜론 누락 등 (비즈니스 로직 변경 없음) |
| **refactor** | 코드 리팩토링 (결과 변경 없이 내부 구조 개선) |
| **test**  | 테스트 코드 추가 또는 수정         |
| **chore** | 빌드, 패키지 매니저 등 기타 잡일     |

### 1.3. 규칙

- **언어**: 커밋 메시지는 **한글**로 작성하는 것을 원칙으로 합니다.
- **제목(Subject)**:
  - 50자 이내로 간결하게 작성합니다.
  - "Fixed", "Added"와 같은 과거형이 아닌 **현재형 또는 명령문**으로 작성합니다.
  - 마침표로 끝나지 않습니다.
- **본문(Body)**:
  - 선택 사항이지만, 변경 내용이 복잡할 경우 상세히 작성합니다.
  - 어떻게(How)보다는 **무엇을(What), 왜(Why)** 변경했는지에 초점을 맞춰 설명합니다.
  - 한 줄의 길이는 72자를 넘지 않도록 합니다.

---

## 2. 코딩 컨벤션 (Coding Convention)

본 프로젝트는 **Java 21** 및 **Spring Boot 3.4** 환경에 최적화된 코딩 컨벤션을 따릅니다.
기본적으로 [Google Java Style Guide](https://google.github.io/styleguide/javaguide.html)를 준수하되, 아래 추가 규칙을 적용합니다.

### 2.1. JavaDoc

- 모든 `public` 클래스와 메서드 상단에는 JavaDoc을 작성하여 기능, 파라미터, 반환 값 등을 명확히 설명합니다.
- 복잡한 내부 로직이나 비즈니스 규칙이 포함된 `protected`, `private` 메서드에도 필요에 따라 JavaDoc을 작성할 수 있습니다.

### 2.2. Entity 설계

- **@Setter 사용 금지**: 객체의 일관성과 불변성을 유지하기 위해 Entity 클래스 내에서 `@Setter` 사용을 금지합니다.
- **생성자를 통한 초기화**: 모든 필드는 생성자(Constructor)를 통해 주입하고 초기화합니다. 객체 생성 시점에 필요한 모든 값이 주입되도록 하여 완전한 상태의 객체를 만듭니다.
- **상태 변경**: Entity의 상태 변경이 필요한 경우, 비즈니스 로직을 담은 명시적인 이름의 메서드를 추가하여 처리합니다. (예: `cancelOrder()`, `updateProfile()`)

### 2.3. JPA (Java Persistence API)

- **지연 로딩(Lazy Loading)**: 모든 연관관계는 `FetchType.LAZY`로 설정하여 불필요한 즉시 로딩을 방지하고 성능을 최적화합니다.
- **연관관계 편의 메서드**: 양방향 연관관계를 설정할 경우, 두 객체의 참조를 모두 업데이트하는 편의 메서드를 작성하여 참조 무결성을 유지합니다. (예: `Post` 클래스의 `addComment(Comment comment)`)

### 2.4. 롬복 (Lombok)

- 과도한 Lombok 사용은 코드의 가독성을 해칠 수 있습니다. 아래 어노테이션 위주로 제한적으로 사용합니다.
  - **`@Getter`**: 필드의 Getter 메서드를 자동 생성합니다.
  - **`@NoArgsConstructor(access = AccessLevel.PROTECTED)`**: JPA 프록시 기술 등을 위해 기본 생성자가 필요한 경우 사용하며, 무분별한 객체 생성을 막기 위해 `protected` 접근 제어자를 사용합니다.
  - **`@ToString`**: 디버깅 목적으로 사용하되, 순환 참조가 발생하지 않도록 `exclude` 속성을 적절히 활용합니다.
  - `@EqualsAndHashCode`, `@Data` 등은 잠재적인 문제를 야기할 수 있으므로 사용을 지양합니다.

### 2.5. 객체지향 설계

- **상속보다 합성(Composition over Inheritance)**: 클래스 간의 강한 결합을 피하고 유연성을 높이기 위해 상속보다는 합성을 우선적으로 사용합니다.
- **인터페이스 기반 설계**: 핵심 로직은 인터페이스에 의존하도록 설계하여 구현체의 변경이 다른 부분에 미치는 영향을 최소화하고, 테스트 용이성을 확보합니다.
